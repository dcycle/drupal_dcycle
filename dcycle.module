<?php

/**
 * @file
 * Functions used during dcycle development.
 * See http://dcycleproject.org/
 */

define('DCYCLE_DEFAULT_POLICY', 'dcycleQuickstartPolicy');

/**
 * Implements hook_menu().
 */
function dcycle_menu() {
  $items['admin/config/development/dcycle'] = array(
    'title' => 'dcycle',
    'description' => 'Manage development policies, mock objects, deployment, continuous integration, test-driven development, behaviour-driven development..',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('dcycle_settings'),
    'access arguments' => array('administer site configuration'),
    'file' => 'dcycle.admin.inc',
  );

  $items['admin/dcycle/identifier'] = array(
    'page callback' => 'dcycle_menu_identifier_json',
    'access callback' => TRUE,
  );
  return $items;
}

/**
 * Menu callback returning dcycle_menu_identifier() in the form of json.
 */
function dcycle_menu_identifier_json() {
  die(drupal_json_encode(array('identifier' => dcycle_menu_identifier())));
}

/**
 * Gets a unique identifier for this environment.
 *
 * Used by drush dcycle-test to determine if the base_url in settings.php
 * is actually the site we think it is, allowing us to avoid incomprehensible
 * errors if it is not.
 */
function dcycle_menu_identifier() {
  if (variable_get('dcycle_site_id', 'not set') == 'not set') {
    variable_set('dcycle_site_id', rand(1000000000, 9999999999));
  }
  return variable_get('dcycle_site_id', 'not set');
}

/**
 * The version of dcycle
 *
 * Sites should state which version of dcycle they are using by
 * setting the variable 'dcycle_version'. For example if you have
 * activated the php module on your site, you are not compliant with
 * later versions of dcycle and should set your 'dcycle_version'
 * variable accordingly.
 * The version of dcycle is not entirely correlated with the version
 * of this module, but is correlated, because this module will
 * perform checks for the latest version of the dcycle standard,
 * which may not apply to the version you are using but which will
 * nonetheless appear as errors on admin/reports/status.
 * Please submit a patch if you would like certain checks to be
 * performed only for certain versions of dcycle.
 */
function dcycle_version() {
  return variable_get('dcycle_version', '1.0-dev');
}

/**
 * The version of the website
 *
 * See documentation/version.txt.
 *
 * @throws Exception
 */
function dcycle_site_version() {
  $v = array();
    
  // First see if a version is defined in the .info file of the
  // deployment module. It should be defined only if the code
  // has already successfully passed the jenkins quality gate at
  // least once.
  if ($module = dcycle_deployment_module()) {
    $info = drupal_parse_info_file(drupal_get_path('module', $module) . '/' . $module . '.info');
    if (isset($info['version'])) {
      $v[] = $info['version'];
    }
  }
  // Add -dev to the version number if the environment is dev. For
  // example v. 2013-01-01-dev contains untested code added after
  // the 2013-01-01 version.
  if (dcycle_environment_type() == 'dev') {
    $v[] = dcycle_environment_type();
  }
  // This should never happen
  if (!count($v)) {
    throw new Exception('Environments that are not in dev or test should have versions assigned to them by Jenkins');
  }
  return implode('-', $v);
}

/**
 * The environment type of this site.
 *
 * Most local environments will be dev, as will a common dev site.
 * The production site, and probably staging as well, will be
 * considered prod normally. Newly deployed environments are
 * dev by default; you must set the variable dcycle_environement_type
 * to prod if not. dev and prod are the only supported environment
 * types
 */
function dcycle_environment_type() {
  return variable_get('dcycle_environment_type', 'dev');
}

/**
 * Get namespace
 */
function dcycle_namespace() {
  $deployment_module = dcycle_deployment_module();
  if ($deployment_module) {
    return drupal_substr($deployment_module, 0, drupal_strlen($deployment_module) - drupal_strlen('_deploy'));
  }
  else {
    return NULL;
  }
}

/**
 * Get the deployment module name.
 *
 * Most local environments will be dev, as will a common dev site.
 * The production site, and probably staging as well, will be
 * considered prod normally. Newly deployed environments are
 * dev by default; you must set the variable dcycle_environement_type
 * to prod if not. dev and prod are the only supported environment
 * types
 *
 * @throws Exception
 */
function dcycle_deployment_module() {
  // get all modules. We are using dcycle_mockable here so that, during
  // testing and developing, we can simulate the presence of absence of
  // certain modules
  $modules = dcycle_mockable('modules');
  // there should be only one candidate
  $candidates = array();
  // find all candidate modules which adhere to
  // sites/*/modules/custom/*_deploy
  foreach ($modules as $module) {
    // figure out the module's path
    $path = dcycle_mockable('drupal_get_path', array('type' => 'module', 'name' => $module));
    if (drupal_substr($module, drupal_strlen($module) - drupal_strlen('_deploy')) == '_deploy') {
      if (drupal_substr($path, drupal_strlen($path) - drupal_strlen('/custom/' . $module) == '/custom/' . $module)) {
        $candidates[] = $module;
      }
    }
  }

  switch (count($candidates)) {
    case 0:
      // Don't throw an exception if there are none. This is not
      // an error but a normal situation when dcycle is first installed.
      return NULL;
      break;
    case 1:
      // During normal development we'll have exactly one candidate
      return $candidates[0];
      break;
    default:
      // Any other count and an exception is thrown.
      throw new Exception(t('There can\'t be more than one deployment module. Currently defined are @m', array('@m' => implode(', ', $candidates))));
      break;
  }
}

/**
 * Returns the current policy. Check validity with dcycle_policy_exists().
 *
 * If you have selected a valid policy, then disabled the policy's associated
 * module, this function may return an invalid policy.
 *
 * @return the module name and policy object name in a json format
 */
function dcycle_policy() {
  $var_result = variable_get('dcycle_policy', 'dcycle:' . DCYCLE_DEFAULT_POLICY);

  // we now need to return this as an array.
  $var_array = explode(':', $var_result);
  return array(
    'module' => $var_array[0],
    'class-name' => $var_array[1],
  );
}

/**
 * Returns the current policy. Check validity with dcycle_policy_exists().
 *
 * If you have selected a valid policy, then disabled the policy's associated
 * module, this function may return an invalid policy.
 *
 * @policy
 *   A policy in the form of an associative array with 'class-name' and
 *   'module'.
 *
 * @return
 *   TRUE if the policy exists
 */
function dcycle_policy_exists($policy) {
  $file = 'includes/dcycle_policies/' . $policy['class-name'] . '/' . $policy['class-name'];
  module_load_include('inc', $policy['module'], $file);
  return class_exists($policy['class-name']);
}

/**
 * Returns the current policy in the form of a key.
 *
 * Used to create key value pairs where the key must be unique. This
 * is used in select lists, for example.
 *
 * @return
 *   A policy key in the format module:clasname
 */
function dcycle_policy_key() {
  $policy = dcycle_policy();
  return $policy['module'] . ':' . $policy['class-name'];
}

/**
 * Returns the current policy
 *
 * @return a dcycleBasePolicy object
 *
 * @throws Exception if the policy object cannot be created for any reason
 */
function dcycle_policy_object($policy = NULL) {
  if (!$policy) {
    $policy = dcycle_policy();
  }
  if (!module_exists($policy['module'])) {
    throw new Exception('The module ' . $policy['module'] . ' does not exist or is not enabled');
  }
  $file = 'includes/dcycle_policies/' . $policy['class-name'] . '/' . $policy['class-name'];
  if (!module_load_include('inc', $policy['module'], $file)) {
    throw new Exception('The expected file ' . $file . ' does not exist in the module ' . $policy['module']);
  }
  if (class_exists($policy['class-name'])) {
    return new $policy['class-name'];
  }
  else {
    throw new Exception($policy['class-name'] . ' is not a class');
  }
}

/**
 * Return the available policies in a key => name array
 *
 * @return
 *   An associative array of policy keys and policy names. The policy key
 *   itself is in the format module:policyClass
 */
function dcycle_get_available_policies() {
  // @TODO don't hardcode this
  $policies = array(
    'dcycle:dcycleQuickstartPolicy' => 'dcycle Quickstart policy',
    'dcycle:dcyclePolicy' => 'dcycle policy',
  );

  // It is possible that another policy was selected, and then the
  // module was disabled, in which case that policy is now selected
  // but broken. It should still be listed as available.
  $policy = dcycle_policy();
  if (!dcycle_policy_exists($policy)) {
    $policies = array_merge($policies, array(
      dcycle_policy_key() => '[' . t('broken') . '] ' . $policy['class-name'],
    ));
  }
  return $policies;
}

/**
 * Implements hook_requirements().
 *
 * Requirements are the backbone of what is dcycle. For many of
 * dcycle's requirements, checks are made here and the report
 * can be found on admin/reports/status
 *
 * @param $info
 *   An array which can contain the environment type, if different from
 *   the current environment type. This is useful for live previews on
 *   admin/config/development/dcycle
 */
function dcycle_requirements($phase) {
  $requirements = array();
  try {
    $policy = dcycle_policy();
    module_load_include('inc', 'dcycle', 'includes/dcycle_policies/' . $policy['class-name'] . '/' . $policy['class-name']);
    $requirements = dcycleBasePolicy::_RenderedRequirements($policy);
  }
  catch (Exception $e) {
    $requirements['dcycle_exception'] = array(
      'title' => $e->getMessage(),
      'value' => '',
      'severity' => REQUIREMENT_ERROR,
      'weight' => -1,
    );
  }
  return $requirements;
}

/**
 * Get simpletest groups for a given module
 */
function dcycle_module_simpletests($module) {
  $all_groups = simpletest_test_get_all();
  $info = drupal_parse_info_file(drupal_get_path('module', $module) . '/' . $module . '.info');
  $files = array();
  if (isset($info['files']) && is_array($info['files'])) {
    foreach ($info['files'] as $filename) {
      if (substr($filename, strlen($filename) - strlen('.test'), strlen('.test')) == '.test') {
        $files[] = drupal_get_path('module', $module) . '/' . $filename;
      }
    }
  }
  return $files;
}

/**
 * Abstraction for a mockable function and its arguments.
 *
 * For example, you might want to interact with the shell from your
 * module; i.e. you want to call shell_exec('which drush') and make sure
 * drush exists on your system. Two problems arise for testing:
 *
 * (1) you can't control your system: do you have access to it? Are
 *     you on a recognized OS? Is shell_exec() disabled in your php.ini?
 * (2) how do you test for what happens when drush is, or is not enabled
 *     in the PATH?
 *
 * Enter mock objects: instead of interacting directly with shell_exec(),
 * you interact with an abstraction of shell_exec, which can be either
 * your real environment, or, for testing, a mock environment that does
 * whatever you want.
 *
 * For an example, look at how this dcycle module implements mocking
 * for shell_exec().
 *
 * To implement a mock object, follow these steps:
 *
 * (1) Determine what you want to mock, for example time(): during the
 * normal course of execution in production, you want time() to return
 * the real actual time (this is just meant as an example; in Drupal you
 * would rarely call time(), using rather the REQUEST_TIME global)
 *
 * (2) In your code, instead of calling time(), call dcycle_mockable('time').
 *
 * (3) Implement hook_dcycle_mockables(), and make sure one of the keys is
 * 'time'
 *
 * (4) The time key should include an array with the name of your module and
 * the name of the time base class which resides in a file with the same name
 * (see the description of hook_dcycle_mockables() for details).
 *
 * (5) In your mockable class file, implement the real time() implementation
 * and the mock time implementation
 *
 * (6) If your application must do something special when time() is 1 a.m.
 * exactly, you can mock this by adding functions to your mock subclass, and
 * then in the testing code, set it.
 *
 * @param $function
 *   Name of a function which exists in your mockable class.
 * @param $arguments
 *   A single optional argument to pass to that function. (If you need more
 *   than one, use an array).
 *
 * @return
 *   The result of the current implementation of your mockable object.
 *   the current implementation can be real implementation (the real-world
 *   shell_exec(), in this example, on your host environment); or a mock
 *   object. This function asks your base object to instantiate itself with
 *   a subclass and then to call the requested function on its implementation.
 *
 * @throws Exception
 *
 * Tested in tests/dcycle.test
 */
function dcycle_mockable($function) {
  if (module_exists('mockable')) {
  }
  else {
    return call_user_func_array($call, array_splice($args, 1));
  }

  // invoke hook_mockables
  $mockables = module_invoke_all('dcycle_mockables');

  if (isset($mockables[$function])) {
    // call the abstraction of the desired function
    $module = $mockables[$function]['module'];
    // the base class is also the name of the file to be included
    $base_class = $mockables[$function]['base_class'];
    // the real and the mock class must exist

    // include the file and load an object of the class
    dcycle_load_include('inc', $module, 'includes/dcycle_mockable/' . $base_class);
    $object = dcycleMockableBase::getMockable($base_class);
    // return the function's result.
    if (method_exists($object, $function)) {
      return $object->$function($argument);
    }
    else {
      throw new DcycleException(t('Please make sure the function @class::@function exists', array('@class' => get_class($object), '@function' => $function)));
    }
  }
  else {
    dcycle_exception('dcycle_mockable() was called with a function name (@f) that does not exist in module_invoke_all(\'dcycle_mockables\'). Make sure you are using mock objects correctly, see the description of dcycle_mockable().', array('@f' => $function));
  }
}

/**
 * Set the type of mockable object we need.
 *
 * param @type
 *   can be 'real' or 'mock'
 *
 * param @more
 *   if you need finer control over your environment, you can set
 *   the $more parameter to what you want, and then use it within
 *   your mock object.
 */
function dcycle_mockable_set_type($type, $more = array()) {
  module_load_include('inc', 'dcycle', 'includes/dcycle_mockable/dcycleMockableBase');
  dcycleMockableBase::setType($type, $more);
}

/**
 * Implements hook_dcycle_mockables().
 */
function dcycle_dcycle_mockables() {
  $mockables = array();

  $mockables['shell_exec'] = array(
    'module' => 'dcycle',
    'base_class' => 'dcycleMockableShell',
  );
  $mockables['modules'] = array(
    'module' => 'dcycle',
    'base_class' => 'dcycleMockableModules',
  );
  $mockables['drupal_get_path'] = array(
    'module' => 'dcycle',
    'base_class' => 'dcycleMockableModules',
  );

  return $mockables;
}

/**
 * Allow control over the mock object.
 *
 * This is generally used during testing, or can be used during
 * development as well to see how your site reacts when, for example,
 * time() is exactly 1 a.m. (see the example with time() in the comments
 * in dcycle_mockable())
 *
 * You can use this with, for exampele, dcycle_mockable_set('dcycle',
 * ''dcycleMockableShell', 'dcycleMockShell', 'setDrush', 'whatever')
 *
 * The above, used in tests/dcycle.test, calls setDrush on dcycleMockShell,
 * thereby simulating that in future calls, the system will act as though
 * the path to drush in PATH is whatever.
 *
 * This may be preferable to calling the function directly because this
 * throws an Exception if there is a problem instead of just dying; also
 * it allows you to use one line instead of two.
 *
 * @param module
 *   The module managing this mock object
 * @param class
 *   The class of the mock object.
 * @param function
 *   The function to call on the mock object.
 * @param argument
 *   The argument to pass to the function
 *
 * @throws DcycleException
 */
function dcycle_mockable_set($module, $file, $class, $function, $argument) {
  dcycle_load_include('inc', $module, 'includes/dcycle_mockable/' . $file);
  $class::$function($argument);
}

/**
 * Throws an exception and notes the calling function
 *
 * Use instead of throw new Exception(x) if you would like the calling function
 * to appear in the message.
 *
 * @throws Exception, of course.
 */
class DcycleException extends Exception {
  /**
   * Construct the exception by adding the calling function to it.
   */
  public function __construct($message) {
    parent::__construct($message . ' ' . dcycle_calling_function(1));
  }
}

/**
 * Utility: Returns the calling function through a backtrace
 *
 * See http://mediatribe.net/en/node/68
 */
function dcycle_calling_function($level = 0) {
  // a function x has called a function y which called this
  // see http://stackoverflow.com/questions/190421/caller-function-in-php-5
  $caller = debug_backtrace();
  $caller = $caller[$level + 2];
  $r = $caller['function'] . '()';
  if (isset($caller['class'])) {
    $r .= ' in ' . $caller['class'];
  }
  if (isset($caller['object'])) {
    $r .= ' (' . get_class($caller['object']) . ')';
  }
  return '[' . $r . ']';
}

/**
 * Utility function like module_load_include(), but throws Exception.
 *
 * See module_load_include() for details.
 *
 * @throws Exception
 */
function dcycle_load_include($type, $module, $file) {
  if (!module_load_include($type, $module, $file)) {
    throw new DcycleException(t('@module/@file.@type failed to load', array('@module' => $module, '@file' => $file, '@type' => $type)));
  }
}
